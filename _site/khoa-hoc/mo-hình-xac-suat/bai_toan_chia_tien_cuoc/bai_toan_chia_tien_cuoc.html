<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nguyễn Tấn Nhựt">
<meta name="dcterms.date" content="2025-03-08">

<title>BÀI TOÁN CHIA TIỀN CƯỢC – ZO Math</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f3c2ea88cadbcfb37ba28ffa2c97cfc1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
</head><body class="nav-fixed">\usepackage{forest}

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../custom.css">




<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">ZO Math</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Trang chủ</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">Giới thiệu</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../shop/index.html"> 
<span class="menu-text">Cửa hàng</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../contact.html"> 
<span class="menu-text">Liên hệ</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#bài-toán" id="toc-bài-toán" class="nav-link active" data-scroll-target="#bài-toán">Bài toán</a>
  <ul class="collapse">
  <li><a href="#tỷ-số-điểm" id="toc-tỷ-số-điểm" class="nav-link" data-scroll-target="#tỷ-số-điểm">Tỷ số điểm</a></li>
  <li><a href="#tỷ-số-kịch-bản-thắng" id="toc-tỷ-số-kịch-bản-thắng" class="nav-link" data-scroll-target="#tỷ-số-kịch-bản-thắng">Tỷ số kịch bản thắng</a></li>
  <li><a href="#tỷ-số-kịch-bản-thắng-mở-rộng" id="toc-tỷ-số-kịch-bản-thắng-mở-rộng" class="nav-link" data-scroll-target="#tỷ-số-kịch-bản-thắng-mở-rộng">Tỷ số kịch bản thắng mở rộng</a></li>
  <li><a href="#xác-suất" id="toc-xác-suất" class="nav-link" data-scroll-target="#xác-suất">Xác suất</a></li>
  </ul></li>
  <li><a href="#mô-hình-toán-học-cho-bài-toán" id="toc-mô-hình-toán-học-cho-bài-toán" class="nav-link" data-scroll-target="#mô-hình-toán-học-cho-bài-toán">Mô hình toán học cho bài toán</a>
  <ul class="collapse">
  <li><a href="#không-gian-mẫu" id="toc-không-gian-mẫu" class="nav-link" data-scroll-target="#không-gian-mẫu">Không gian mẫu</a></li>
  <li><a href="#xác-suất-1" id="toc-xác-suất-1" class="nav-link" data-scroll-target="#xác-suất-1">Xác suất</a></li>
  <li><a href="#biến-cố" id="toc-biến-cố" class="nav-link" data-scroll-target="#biến-cố">Biến cố</a></li>
  <li><a href="#biến-ngẫu-nhiên" id="toc-biến-ngẫu-nhiên" class="nav-link" data-scroll-target="#biến-ngẫu-nhiên">Biến ngẫu nhiên</a></li>
  <li><a href="#phân-phối-xác-suất" id="toc-phân-phối-xác-suất" class="nav-link" data-scroll-target="#phân-phối-xác-suất">Phân phối xác suất</a></li>
  </ul></li>
  <li><a href="#tổng-quát-hóa" id="toc-tổng-quát-hóa" class="nav-link" data-scroll-target="#tổng-quát-hóa">Tổng quát hóa</a></li>
  <li><a href="#thư-mục" id="toc-thư-mục" class="nav-link" data-scroll-target="#thư-mục">Thư mục</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">BÀI TOÁN CHIA TIỀN CƯỢC</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Nguyễn Tấn Nhựt </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 8, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><strong>Ghi chú.</strong> Trong tiếng Anh bài toán này thường được gọi bằng cái tên “the problem of points” thay vì “the problem of division of the stakes”. Theo mình nghĩ, lí do, là vì muốn nhấn mạnh vào phương pháp kỳ vọng để giải quyết bài toán. Điểm số có thể xem là một biến ngẫu nhiên.</p>
<section id="bài-toán" class="level2">
<h2 class="anchored" data-anchor-id="bài-toán">Bài toán</h2>
<p><strong>Chúng mình hãy cùng chơi trò tung đồng xu, mỗi người chọn một mặt để ghi điểm cho mình. Ai ghi đủ 3 điểm trước sẽ thắng toàn bộ số tiền cược. Nếu trò chơi phải dừng vào lúc bạn có 2 điểm và mình có 1 điểm, chúng mình phải chia tiền cược như thế nào?</strong></p>
<p>Mục tiêu của chúng mình là tìm một cách hợp lý để chia số tiền cược khi trò chơi phải dừng lại sớm, chưa có người thắng cuộc. Hợp lý được hiểu là phần tiền mà bạn nhận được phải tương xứng với vị thế của bạn đang có, tránh tình trạng gây bất mãn cho một bên. Chúng mình sẽ bắt đầu học từ những cách chia sai lầm cho đến khi tìm ra cách chia phù hợp nhất với tình thế của mỗi người.</p>
<section id="tỷ-số-điểm" class="level3">
<h3 class="anchored" data-anchor-id="tỷ-số-điểm">Tỷ số điểm</h3>
<p>Một cách chia đơn giản là dựa vào <em>tỷ số điểm hiện tại</em>, tức là 2:1. Theo cách này, bạn sẽ nhận 2 phần vì đang có 2 điểm, còn mình nhận 1 phần vì có 1 điểm. Nhưng liệu điều đó có thật sự hợp lý? Để làm rõ, hãy xét hai trường hợp dưới đây.</p>
<p>Giả sử bạn có 1 điểm và mình chưa có điểm nào. Theo cách chia trên, bạn sẽ nhận toàn bộ tiền cược, còn mình ra về tay trắng. Điều này quá bất công, vì trò chơi chưa ngã ngũ, và chỉ một ván thắng của bạn không đủ để quyết định kết cục toàn bộ trò chơi.</p>
<p>Bây giờ, giả sử luật chơi yêu cầu 55 điểm để chiến thắng, và lúc dừng lại, bạn có 54 điểm, còn mình có 45 điểm. Nếu chia theo tỷ lệ 54:45, tiền cược sẽ được chia gần như đồng đều, nhưng rõ ràng tình thế của chúng mình rất khác nhau: chỉ cần một chiến thắng nữa là bạn có thể nhận toàn bộ số tiền, trong khi mình sẽ cần đến 10 lần chiến thắng liên tiếp để đạt được điều đó. Chắc chắn bạn sẽ không hài lòng với cách chia này, vì lợi thế đang nghiêng về phía bạn.</p>
<p>Chia theo tỷ số điểm chỉ dựa vào số vòng thắng của mỗi người chơi đến thời điểm dừng, nhưng điều này bỏ qua khả năng thắng thua trong những vòng tiếp theo. Cách suy luận này không tính đến cơ hội còn lại của mỗi người chơi, dẫn đến việc chia tiền cược không công bằng nếu trò chơi dừng lại sớm, hoặc có một người sắp về đích.</p>
<!--Chính các khả năng này mới là yếu tố then chốt để chia tiền một cách công bằng hơn.-->
<p><strong>Câu hỏi.</strong> <em>Nhằm sửa chữa sai lầm trong việc chia theo tỷ số điểm, mình lập luận rằng: Vì bạn hơn mình 1 điểm và nó chiếm 1/3 số điểm chiến thắng, nên bạn sẽ nhận 1/3 phần tiền cược của mình góp vào. Do đó, phần tiền mà bạn nhận được là <span class="math inline">\(\frac{1}{2}+\frac{1}{2}\cdot\frac{1}{3}=\frac{2}{3}\)</span>, hay nói cách khác chúng mình vẫn chia theo tỷ số 2:1 nghiêng về bạn. Với cách lập luận này, khi bạn có 1 điểm và mình chưa có điểm, cũng chia theo tỷ số 2:1, có vẻ như đã khắc phục được tình trạng cực đoan tạo ra bởi tỷ số điểm. Theo bạn chúng mình có nên áp dụng cách chia này?</em></p>
</section>
<section id="tỷ-số-kịch-bản-thắng" class="level3">
<h3 class="anchored" data-anchor-id="tỷ-số-kịch-bản-thắng">Tỷ số kịch bản thắng</h3>
<p>Chúng mình đang ở tình huống bạn có 2 điểm và mình có 1 điểm, nghĩa là đã trải qua 3 ván. Nếu trò chơi tiếp tục, các kịch bản có thể xảy là:</p>
<ul>
<li><p>Bạn thắng ván thứ tư: bạn thắng chung cuộc, ký hiệu là <span class="math inline">\((\_,\_,\_,b)\)</span>.</p></li>
<li><p>Mình thắng ván thứ tư, và bạn thắng ván thứ năm: bạn thắng chung cuộc, ký hiệu là <span class="math inline">\((\_,\_,\_,m,b)\)</span>.</p></li>
<li><p>Mình thắng ván thứ tư và thứ năm: mình thắng chung cuộc, ký hiệu là <span class="math inline">\((\_,\_,\_,m,m)\)</span>.</p></li>
</ul>
<p>Dựa vào các kịch bản trên, chúng mình vẫn chia theo tỷ số 2:1 không khác gì việc dựa theo tỷ số điểm đã bàn qua trước kia. Tuy nhiên, luận giải theo hướng này lại tránh được một trường hợp cực đoan: tại thời điểm dừng mà bạn có 1 điểm và mình chưa có điểm nào, sẽ chia theo tỷ số 3:2 thay vì 1:0 mà vừa nhìn vào đã thấy phi lý. Chính chỗ tốt này sẽ khiến chúng mình vội chấp nhận cách chia có vấn đề này. Cách đếm kịch bản chỉ dựa vào số lượng mà chưa xét đến khả năng xảy ra của từng kịch bản, dẫn đến sự không chính xác. Giả sử kịch bản thắng của bạn dễ xảy ra hơn, hoặc ngược lại, kịch bản thắng của mình lại dễ xảy ra hơn cả hai kịch bản của bạn gộp lại thì sao?</p>
</section>
<section id="tỷ-số-kịch-bản-thắng-mở-rộng" class="level3">
<h3 class="anchored" data-anchor-id="tỷ-số-kịch-bản-thắng-mở-rộng">Tỷ số kịch bản thắng mở rộng</h3>
<p>Giải pháp là mở rộng các kịch bản để chúng có độ dài bằng nhau, bất kể kết quả dừng sớm. Như vậy, mỗi kịch bản có khả năng đóng góp công bằng vào kết quả cuối cùng. Chúng mình sẽ mở rộng các kịch bản như sau:</p>
<ul>
<li><p>Nếu bạn thắng ván thứ tư <span class="math inline">\((\_,\_,\_,b)\)</span>, thì vẫn tiếp tục chơi ván thứ năm, dù không thực sự cần thiết, tạo ra hai kịch bản mở rộng là <span class="math inline">\((\_,\_,\_,b,b)\)</span> và <span class="math inline">\((\_,\_,\_,b,m)\)</span>.</p></li>
<li><p>Với hai kịch bản còn lại là <span class="math inline">\((\_,\_,\_,m,b)\)</span> và <span class="math inline">\((\_,\_,\_,m,m)\)</span>, chúng ta không cần mở rộng.</p></li>
</ul>
<p>Bây giờ, chúng mình có đến 4 kịch bản, trong đó bạn thắng 3 kịch bản, còn mình thắng 1 kịch bản. Tỷ lệ chia tiền lúc này là 3:1 nghiêng về phía bạn. Chúng mình có thể hiểu phương pháp mở rộng kịch bản đơn giản là tạo ra các tình huống giả định mà trò chơi kéo dài thêm một ván, dù người thắng có thể đã được xác định. Cách này không làm thay đổi điều kiện trò chơi, nhưng sẽ giúp chúng mình thấy được tất cả các khả năng có thể xảy ra và từ đó chia phần cược một cách công bằng.</p>
<p>Để hiểu vì sao mở rộng kịch bản là được phép, mình sẽ thay đổi quy tắc trò chơi như sau:</p>
<p><strong>Chúng mình chơi trò tung đồng xu, với tổng cộng 5 lần tung, ai ghi đủ 3 điểm trước sẽ thắng. Nếu trò chơi bị dừng khi bạn có 2 điểm và mình có 1 điểm, chúng mình phải chia tiền cược như thế nào?</strong></p>
<p>Với thay đổi nhỏ này, các kịch bản mở rộng đã trở thành các kịch bản chính thức của trò chơi: <span class="math inline">\((\_,\_,\_,b,b)\)</span>, <span class="math inline">\((\_,\_,\_,b,m)\)</span>, <span class="math inline">\((\_,\_,\_,m,b)\)</span> và <span class="math inline">\((\_,\_,\_,m,m)\)</span>.</p>
<p>Lúc này, tỷ lệ chia tiền là 3:1 nghiêng về phía bạn, hoàn toàn hợp lý. Sự thay đổi nhỏ này chỉ thêm một quy tắc “giả định” về số lần tung đồng xu tối đa, nhưng không làm thay đổi điều kiện chiến thắng ban đầu là người nào ghi được 3 điểm trước sẽ thắng trò chơi. Vì vậy, khi một người đạt 3 điểm, trò chơi vẫn sẽ kết thúc ngay tại đó. Điều này có nghĩa là số lần tung đồng xu tối đa chỉ tạo ra thêm các kịch bản giúp chúng ta có thể đánh giá công bằng hơn về khả năng thắng của mỗi người tại thời điểm trò chơi dừng lại.</p>
<p>Bằng cách giữ nguyên điều kiện chiến thắng và thêm quy tắc 5 lần tung, chúng mình chỉ đang mở rộng không gian kịch bản nhưng không thay đổi bản chất của trò chơi. Điều này giúp đảm bảo rằng mọi khả năng đều được tính đến mà không làm trò chơi trở nên khác biệt về cách kết thúc hay kết quả cuối cùng. Việc thêm vào quy tắc 5 lần tung không gây cản trở gì nếu bạn thắng ván thứ tư và không muốn đi tiếp ván thứ năm (có đi cũng vậy). Như thế, có hay không có quy tắc 5 lần tung, hai trò chơi này là một.</p>
<p><strong>Câu hỏi.</strong> <em>Giả sử trò chơi dừng lại khi bạn cần thêm <span class="math inline">\(m\)</span> điểm và mình cần thêm <span class="math inline">\(n\)</span> điểm để giành chiến thắng. Hỏi số tiền cược nên chia thế nào?</em></p>
<p><strong>Gợi ý.</strong> Số tiền cược nên được chia theo tỷ số <span class="math inline">\(\sum_{i=m}^{m+n-1}\binom{m+n-1}{i}:\sum_{i=0}^{m-1}\binom{m+n-1}{i}\)</span> tương ứng cho bạn và mình. Trong đó, ký hiệu <span class="math inline">\(\binom{r}{s}\)</span> là số tập con <span class="math inline">\(s\)</span> phần tử của tập <span class="math inline">\(r\)</span> phần tử, hay tổ hợp chập <span class="math inline">\(s\)</span> của <span class="math inline">\(r\)</span>.</p>
</section>
<section id="xác-suất" class="level3">
<h3 class="anchored" data-anchor-id="xác-suất">Xác suất</h3>
<p>Chúng mình hãy tưởng tượng thế này nhé: mỗi lần tung đồng xu là một cơ hội để không bạn thì mình tiến gần hơn tới chiến thắng. Khi trò chơi phải dừng lại lúc bạn có 2 điểm và mình có 1 điểm, bạn có lợi thế lớn hơn do đang dẫn trước. Nhưng lợi thế của bạn lớn đến mức nào?</p>
<p>Để hình dung được mức độ lợi thế của bạn so với mình, chúng mình sẽ tìm ra những con số có thể phản ánh khả năng chiến thắng của mỗi người nếu trò chơi được tiếp tục. Hơn nữa, các con số này sẽ giúp chúng mình quyết định phần tiền tương xứng với vị thế của mỗi người.</p>
<p>Như đã phân tích, việc phân chia tiền cược dựa trên các kịch bản mở rộng giúp khắc phục hạn chế về mức độ xảy ra không đồng đều giữa các kịch bản khác nhau. Trong bài toán đang xét, kịch bản <span class="math inline">\((\_,\_,\_,b)\)</span> có khả năng xảy ra cao hơn so với các kịch bản <span class="math inline">\((\_,\_,\_,m,b)\)</span> và <span class="math inline">\((\_,\_,\_,m,m)\)</span>. Nguyên nhân là do kịch bản <span class="math inline">\((\_,\_,\_,b)\)</span> chỉ cần bạn thắng một lần ở ván thứ tư để trò chơi kết thúc, trong khi kịch bản <span class="math inline">\((\_,\_,\_,m,b)\)</span> đòi hỏi bạn phải thua ở ván thứ tư và sau đó thắng ở ván thứ năm. Cái nào cần nhiều điều kiện hơn sẽ khó xảy ra hơn.</p>
<p>Vì vậy, để có cách chia phần thưởng công bằng, chúng mình cần tìm một cách đo lường mức độ xảy ra của các kịch bản này, bất kể độ dài ngắn của chúng. Từ đó, chúng mình có thể xác định được mức độ thắng của mỗi bên.</p>
<p>Cụ thể, chúng mình đã đồng ý chia tiền cược theo tỷ số 3:1, nghĩa là bạn sẽ nhận <span class="math inline">\(\frac{3}{4}\)</span> số tiền cược và mình thì nhận <span class="math inline">\(\frac{1}{4}\)</span> còn lại. Ở đây, các con số <span class="math inline">\(\frac{3}{4}\)</span> và <span class="math inline">\(\frac{1}{4}\)</span> được xem là thước đo mức độ thắng tương ứng của bạn và của mình. Những tỷ lệ này dựa trên số lượng kịch bản thắng cho mỗi bên, từ đó phản ánh khả năng tương đối của từng bên để đạt được chiến thắng.</p>
<p>Cùng nhớ lại rằng có 3 kịch bản dẫn đến chiến thắng của bạn, chúng bao gồm: <span class="math inline">\((\_,\_,\_,b,b)\)</span>, <span class="math inline">\((\_,\_,\_,b,m)\)</span> và <span class="math inline">\((\_,\_,\_,m,b)\)</span>; và chỉ có 1 kịch bản dẫn đến chiến thắng của mình là <span class="math inline">\((\_,\_,\_,m,m)\)</span>. Tổng cộng có 4 kịch bản, và không có lý do gì để cho rằng cái nào đó trong chúng được ưu tiên hơn những cái còn lại. Do đó, chúng mình sẽ xem mức độ xảy ra của mỗi cái trong chúng là bằng nhau. Hơn nữa, mức độ xảy ra của mỗi kịch bản phải được xem xét trong khuôn khổ so sánh đối chiếu với các kịch bản còn lại, hay con số này phải thể hiện được tỷ lệ giữa kịch bản mà nó đại diện so với toàn bộ các kịch bản đang có. Như vậy, mức độ xảy ra của mỗi kịch bản trong 4 kịch bản này nên là <span class="math inline">\(\frac{1}{4}\)</span>.</p>
<p><strong>Không thể mở rộng cho các trò chơi phức tạp hơn</strong></p>
<p>Trong một trò chơi với nhiều điểm hơn (ví dụ: ai đạt 5 điểm trước sẽ thắng), số lượng kịch bản có thể tăng lên rất nhiều, và việc đếm từng kịch bản trở nên không thực tế. Đồng thời, có thể có các chuỗi chiến thắng dài cho mỗi bên với những xác suất hoàn toàn khác nhau. Trong trường hợp này, cách đếm kịch bản sẽ không thể hiện đúng lợi thế của mỗi người khi trò chơi dừng lại, vì chỉ số lượng kịch bản không đủ để phân tích sự chênh lệch về khả năng thắng thực tế.</p>
<p>Hãy tưởng tượng rằng mỗi kịch bản đều có thể xảy ra trong một bối cảnh rất khác nhau. Ví dụ, trong kịch bản thứ nhất, bạn đã có một lợi thế rõ rệt về điểm số và có khả năng thắng rất cao. Trong khi đó, ở kịch bản thứ hai, mình có thể vừa tạo ra một bước ngoặt trong trò chơi. Do đó, cách phân chia dựa vào số lượng kịch bản này không thể hiện được một cách công bằng cơ hội và khả năng thắng cuộc của từng người.</p>
<p>Chia theo tỷ số kịch bản, cũng như chia theo tỷ số điểm, chỉ dựa trên kết quả tạm thời mà không xem xét đến quy trình và động lực của trò chơi. Điều này có thể dẫn đến những quyết định không công bằng và không phản ánh đúng thực tế của cơ hội chiến thắng của mỗi người.</p>
<p>Vì vậy, cần phải xem xét một phương pháp chia khác, nơi mà các yếu tố ảnh hưởng đến cơ hội chiến thắng được đánh giá một cách đầy đủ hơn, để đảm bảo rằng cách chia tiền cược thực sự công bằng và hợp lý.</p>
<p><strong>Câu hỏi.</strong> Phải chăng một khi bạn có nhiều điểm hơn mình tại thời điểm dừng thì số kịch bản thắng cuộc của bạn nếu trò chơi được tiếp tục luôn nhiều hơn mình, hơn nữa còn có những kịch bản có khả năng xảy ra lớn hơn các kịch bản khác?</p>
<p><strong>Câu hỏi.</strong> Số điểm bạn và mình có khi trò chơi dừng lại có liên hệ với số kịch bản diễn ra sau đó. Có thể tìm một công thức cho mối liên hệ này không?</p>
</section>
</section>
<section id="mô-hình-toán-học-cho-bài-toán" class="level2">
<h2 class="anchored" data-anchor-id="mô-hình-toán-học-cho-bài-toán">Mô hình toán học cho bài toán</h2>
<p>Để tìm cách mô hình hóa bài toán này, các câu hỏi đầu tiên mà mình tự đặt ra là:</p>
<ul>
<li><p>Trò chơi này sẽ diễn ra như thế nào nếu không kết thúc giữa chừng?</p></li>
<li><p>Cần tối thiểu và tối đa bao nhiêu ván đấu để phân thắng bại?</p></li>
<li><p>Ngay cả khi nó kết thúc giữa chừng, mình cũng muốn biết trước đó nó đã diễn ra như thế nào? Và sẽ tiếp tục diễn ra như thế nào nếu không dừng lại?</p></li>
</ul>
<p>Rõ ràng khi trò kết thúc, hoặc bạn là người chiến thắng hoặc mình là người chiến thắng. Nếu đó là bạn, diễn biến của trò chơi có thể đã xảy ra theo trình tự</p>
<ol type="1">
<li><p>Ván 1: bạn thắng;</p></li>
<li><p>Ván 2: mình thắng;</p></li>
<li><p>Ván 3: bạn thắng;</p></li>
<li><p>Ván 4: mình thắng;</p></li>
<li><p>Ván 5: bạn thắng.</p></li>
</ol>
<p>Mình sẽ viết gọn lại diễn biến này là (bạn, mình, bạn, mình, bạn) và gọi nó là một kịch bản. Đây chỉ là một trong những kịch bản chiến thắng của bạn, nếu thay đổi vai trò của chúng mình cho nhau, (mình, bạn, mình, bạn, mình) là một kịch bản chiến thắng dành cho mình. Nếu đặc biệt may mắn, kịch bản (bạn, bạn, bạn) xảy ra, lúc này bạn chiến thắng liên tiếp 3 ván ngay từ đầu. Và ngược lại, (mình, mình, mình) là kịch bản may mắn của mình. Bất kỳ kịch bản chiến thắng nào dành cho bạn cũng có thể trở thành kịch bản chiến thắng dành cho mình miễn là thay đổi vai trò của chúng mình cho nhau.</p>
<p>Trò chơi sẽ kết thúc ngay khi có một người ghi được 3 điểm, ví dụ người đó là bạn. Trò chơi sẽ kết thúc nếu bạn ghi liên tiếp 3 điểm. Để bạn ghi liên tiếp 3 điểm, cần ít nhất 3 ván đấu đã diễn ra và đó cũng chính là số ván đấu tối thiểu để phân thắng bại. Ngược lại, nếu sau 3 ván mà trò chơi chưa kết thúc, khi đó số điểm mà mình đã ghi được chỉ có thể là một trong ba con số 0 hoặc 1 hoặc 2. Từ đó suy ra số ván đấu tối đa để bạn giành chiến thắng là 5.</p>
<p>Việc liệt kê ra tất cả các kịch bản của trò chơi không phải đơn giản nếu không có một chút thủ thuật. Mình sử dụng một sơ đồ cây để tránh nhầm lẫn và tầm soát đầy đủ các kịch bản, sơ đồ đó như dưới đây.</p>
<p><img src="images/cay_kich_ban_tro_choi_chia_phan_thuong/cay_kich_ban_tro_choi_chia_phan_thuong.svg" alt="Hình vẽ TikZ dưới dạng SVG"></p>
<p>Dựa vào sơ đồ cây</p>
<p>Dựa vào sơ đồ cây này, mình có thể liệt kê được các kịch bản sau đây:</p>
<table style="border-collapse: separate; border-spacing: 20px;">
<tbody><tr>
<td style="padding: 10px;">
(mình, mình, mình)
</td>
<td style="padding: 10px;">
(mình, mình, bạn, mình)
</td>
<td style="padding: 10px;">
(mình, mình, bạn, bạn, mình)
</td>
<td style="padding: 10px;">
(mình, mình, bạn, bạn, bạn)
</td>
</tr>
<tr>
<td style="padding: 10px;">
(mình, bạn, mình, mình)
</td>
<td style="padding: 10px;">
(mình, bạn, mình, bạn, mình)
</td>
<td style="padding: 10px;">
(mình, bạn, mình, bạn, bạn)
</td>
<td style="padding: 10px;">
(mình, bạn, bạn, mình, mình)
</td>
</tr>
<tr>
<td style="padding: 10px;">
(mình, bạn, bạn, mình, bạn)
</td>
<td style="padding: 10px;">
(mình, bạn, bạn, bạn)
</td>
<td style="padding: 10px;">
(bạn, mình, mình, mình)
</td>
<td style="padding: 10px;">
(bạn, mình, mình, bạn, mình)
</td>
</tr>
<tr>
<td style="padding: 10px;">
(bạn, mình, mình, bạn, bạn)
</td>
<td style="padding: 10px;">
(bạn, mình, bạn, mình, mình)
</td>
<td style="padding: 10px;">
(bạn, mình, bạn, mình, bạn)
</td>
<td style="padding: 10px;">
(bạn, mình, bạn, bạn)
</td>
</tr>
<tr>
<td style="padding: 10px;">
(bạn, bạn, mình, mình, mình)
</td>
<td style="padding: 10px;">
(bạn, bạn, mình, mình, bạn)
</td>
<td style="padding: 10px;">
(bạn, bạn, mình, bạn)
</td>
<td style="padding: 10px;">
(bạn, bạn, bạn)
</td>
</tr>
</tbody></table>
<section id="không-gian-mẫu" class="level3">
<h3 class="anchored" data-anchor-id="không-gian-mẫu">Không gian mẫu</h3>
</section>
<section id="xác-suất-1" class="level3">
<h3 class="anchored" data-anchor-id="xác-suất-1">Xác suất</h3>
</section>
<section id="biến-cố" class="level3">
<h3 class="anchored" data-anchor-id="biến-cố">Biến cố</h3>
</section>
<section id="biến-ngẫu-nhiên" class="level3">
<h3 class="anchored" data-anchor-id="biến-ngẫu-nhiên">Biến ngẫu nhiên</h3>
</section>
<section id="phân-phối-xác-suất" class="level3">
<h3 class="anchored" data-anchor-id="phân-phối-xác-suất">Phân phối xác suất</h3>
</section>
</section>
<section id="tổng-quát-hóa" class="level2">
<h2 class="anchored" data-anchor-id="tổng-quát-hóa">Tổng quát hóa</h2>
<p>Để thực hiện nhiệm vụ này, chúng mình thử tập trung vào những câu hỏi dưới đây:</p>
<ul>
<li><p>Chơi tối đa bao nhiêu vòng sẽ có người thắng toàn bộ số tiền cược?</p></li>
<li><p>Cần tối đa bao nhiêu vòng nữa để thắng toàn bộ số tiền cược nếu giả sử trò chơi được tiếp tục?</p></li>
<li><p>Chúng mình đã chơi bao nhiêu vòng trước khi dừng lại?</p></li>
</ul>
<p>Cần thực hiện ít nhất 5 lần và nhiều nhất 9 lần tung đồng xu cho đến khi một mặt xuất hiện đủ 5 lần. Vì sao? Vì nếu một mặt đã xuất hiện đủ 5 lần, mặt còn lại có thể xuất hiện từ 0 đến 4 lần, số lần tung tối thiểu là <span class="math inline">\(5+0=5\)</span> và tối đa là <span class="math inline">\(5+4=9\)</span>.</p>
<p>Trường hợp biên trên, người có điểm số cao hơn nắm ưu thế rõ ràng. Trường hợp biên dưới, người có điểm số ban đầu cao cũng có lợi thế không tương xứng.</p>
</section>
<section id="thư-mục" class="level2">
<h2 class="anchored" data-anchor-id="thư-mục">Thư mục</h2>
<p><a href="https://en.wikipedia.org/wiki/Problem_of_points">Problem of Points</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 ZO Math - Học toán sáng tạo</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="contact.qmd">Liên hệ</a> | <a href="https://facebook.com/zo-math">Facebook</a></p>
</div>
  </div>
</footer>




</body></html>